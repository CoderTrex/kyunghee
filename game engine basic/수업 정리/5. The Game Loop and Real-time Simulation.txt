모든 게임 시스템에서는 시간을 정의하고 다르게 조절한다.

rendering loop
in 게임의 gui에서 스크린의 내용은 고정적이었다.
- 일정한 부분만 바뀌었다.
- gui는 사각형 무효화라고 알려져 있었다. 바뀌는 부분은 매우 적음

3d 실시간 그래픽에서는 계속해서 내용이 바뀐다.
- 풍경은 3d에서 카메라로 잡히고, 카메라는 연속적으로 움직임
- 움직임의 환영이나 상호작용은 게속해서 계속해서 생성된다. -> 정지된 일련의 이미지를 빠르게 제공함으로써
- 이러한 루프는 일종의 랜더 루프라고 알려져있다.

게임 루프
    게임는 다양한 상호작용 시스템으로 구헝되어있다. 
    i/o디바이스를 포함해서, 이미지 랜더링, 충돌 감지, 해상도, 선택적 강체 동역학 시뮬레이션, 멀티플레이어 네트워킹, 오디오 등
    대부분의 게임 엔진 하위 시스템은 게임이 실행되는 동안 정기적인 서비스가 필요합니다.

    그러나 이러한 하위 시스템에 서비스를 제공해야 하는 속도는 하위 시스템마다 다릅니다.
    애니메이션 30~60hz / 다이나막 물리 시뮬레이션 120hz / ai 시스템 1초에 한 번이어도 충분함

    게임 서브시스템을 가장 쉽게 업데이트 하는 것은 하나의 업데이트 루프를 가지는 것이다.
    우리는 이것을 게임 루프라고 부르고, 하위 시스템을 업데이트 한다.

    일부 게임 엔진 및 게임 미들웨어 패키지는 프레임워크로 구성됩니다.
        • 프레임워크는 부분적으로 구성된 응용 프로그램입니다. 프로그래머는 프레임워크 내에서 누락된 기능의 사용자 정의 구현을 제공하여 응용 프로그램을 완성합니다.
        • 프로그래머는 프레임워크에 의해 제어되기 때문에 애플리케이션 내의 전반적인 제어 흐름을 거의 또는 전혀 제어할 수 없습니다.

타임라인
    ▪ 타임라인은 원점(t=0)이 시스템의 다른 타임라인과 관련된 임의의 위치에 있을 수 있는 연속적인 1차원 축입니다.
    ▪ 정수 또는 부동 소수점 형식으로 절대 시간 값을 저장하는 간단한 시계 변수를 통해 타임라인을 구현할 수 있습니다.
    ▪ 이 타임라인의 기원은 CPU가 마지막으로 전원이 켜졌거나 재설정된 순간과 일치하도록 정의됩니다.
    ▪ CPU 주기 단위로 시간을 측정합니다(초 단위로 쉽게 변환 가능).

    ▪ 우리는 실시간 타임라인으로만 작업하는 것으로 제한할 필요가 없습니다. 
    ▪ 실시간과 기술적으로 독립된 게임 타임라인을 정의할 수 있습니다.
    ▪ 예를 들어 실시간과 독립적인 게임 타임라인을 정의할 수 있습니다.
        •게임을 일시 중지하려면 게임 타임라인 업데이트를 중지하면 됩니다.
        •게임을 슬로우 모션으로 전환하려면 게임 시계를 실시간 시계보다 더 느리게 업데이트할 수 있습니다.
    ▪ 위에서 설명한 접근 방식을 사용할 때 게임이 일시 중지된 경우에도 게임 루프가 계속 실행되고 있음을 인식하는 것이 중요합니다.


타임 라인 매핑
    ▪ 단일 속도로 서로 다른 타임라인을 매핑할 필요가 없습니다.
    ▪ 예를 들어, 애니메이션 클립 또는 오디오 클립은 로컬 타임라인을 가질 수 있으며 해당 재생 속도는 저작 또는 녹화될 때 결정됩니다.
    ▪ 애니메이션 속도를 높이거나 오디오 샘플 속도를 늦추고 싶을 수 있습니다.
    ▪ 로컬 시계를 반대로 실행하여 애니메이션을 거꾸로 재생할 수도 있습니다.
    ▪ 이를 가능하게 하기 위해 로컬 타임라인과 글로벌 타임라인 간의 매핑을 수행할 때 여러 매개 변수가 관련됩니다.

여러 타임라인 관리
    ▪ 멀티스레딩은 중앙 처리 장치(CPU)가 운영 체제에서 지원하는 여러 스레드 실행을 동시에 제공하는 기능입니다.
    ▪ 다중 스레드 기술을 통해 여러 타임라인을 관리할 수 있습니다.
    ▪ 멀티스레딩 방식은 멀티프로세싱과 다릅니다.
        • 스레드는 컴퓨팅 유닛, CPU 캐시 및 변환 색인 버퍼를 포함하는 단일 또는 다중 코어의 리소스를 공유합니다.

멀티스레딩의 장점과 단점 :
▪장점:
    • 한 스레드가 캐시 미스를 많이 받는 경우 다른 스레드는 사용하지 않는 컴퓨팅 리소스를 계속 활용할 수 있으며, 
      이는 단일 스레드만 실행되었다면 이러한 리소스가 idel 상태였을 것이기 때문에 전체 실행 속도가 빨라질 수 있습니다.
    • 스레드가 CPU의 모든 컴퓨팅 리소스를 사용할 수 없는 경우 다른 스레드를 실행하면 해당 리소스가 idle 상태가 되는 것을 방지할 수 있습니다.

▪단점:
    • 캐시 또는 변환 색인 버퍼(TLB)와 같은 하드웨어 리소스를 공유할 때 여러 스레드가 서로 간섭할 수 있습니다. 
      결과적으로 단일 스레드의 실행 시간은 향상되지 않으며 스레드 전환 하드웨어를 수용하는 데 필요한 추가 파이프라인 단계 또는 주파수 감소로 인해 
      하나의 스레드만 실행 중인 경우에도 저하될 수 있습니다.
    • 전체 효율성은 다양합니다. MMX 또는 AltiVecextensions를 사용하고 데이터 프리페치를 수행하는 손으로 조정한 어셈블리 언어 프로그램
           (우수한 비디오 인코더에서와 같이)은 캐시 미스 또는 유휴 컴퓨팅 리소스로 인해 어려움을 겪지 않습니다. 
      따라서 이러한 프로그램은 하드웨어 다중 스레딩의 이점을 얻지 못하고 실제로 공유 리소스 경합으로 인해 성능이 저하될 수 있습니다.
    • 스레드는 동시성의 환상을 제공하는 방식으로 한 번에 하나씩 실행됩니다. 
      따라서 단일 CPU에서 여러 스레드를 실행하면 계산 리소스가 필요한 스레드 스케줄링 문제가 발생합니다.

    TLB란?
    변환 색인 버퍼(Translation Lookaside Buffer, TLB)는 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위해 사용되는 캐시로, 약칭은 TLB이다.[1] 
    TLB는 최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블을 저장하기 때문에 일종의 주소 변환 캐시라고 할 수 있다. 
    TLB는 CPU와 CPU 캐시 사이, CPU 캐시와 메인 메모리 사이 등 여러 가지 다른 레벨의 캐시들 사이에서 주소를 변환하는데 사용할 수 있다. 
    현재 모든 데스크탑 및 서버용 프로세서는 하나 또는 그 이상의 TLB를 메모리 관리 하드웨어에 가지고 있다. 
    페이지 단위나 세그먼트 단위로 처리하는 가상 메모리를 사용하는 거의 모든 하드웨어는 TLB를 사용한다. 
    CPU는 1차적으로 TLB에 접근하여 원하는 페이지가 존재하는지 탐색하고, TLB에 존재하지 않을 경우 MMU의 페이지 테이블을 참조한다.

race Condition
    ▪ 컴퓨터 프로그램이 프로그램의 프로세스나 스레드의 순서나 타이밍에 의존할 때 소프트웨어에서 경합 조건(또는 경합 위험)이 발생합니다.
    ▪ 프로세스나 스레드가 일부 공유 상태에 의존할 때 심각한 경쟁 조건이 자주 발생합니다. 
    공유 상태는 상호 배타적이어야 하는 중요한 섹션에서 수행되어야 합니다. 이 규칙을 따르지 않으면 공유 상태가 손상될 수 있습니다.

프레임 속도
    ▪ 실시간 게임의 프레임 속도는 스틸 3D 프레임 시퀀스가 시청자에게 얼마나 빨리 표시되는지를 나타냅니다.
    ▪ 초당 사이클 수로 정의되는 헤르츠(Hz) 단위는 주기적인 프로세스의 속도를 설명하는 데 사용할 수 있습니다.
    ▪ 게임 및 영화에서 프레임 속도는 일반적으로 초당 프레임 수(FPS)로 측정됩니다. 
    ▪ 영화는 전통적으로 24FPS에서 실행됩니다.
    ▪ 게임은 일반적으로 30 ~ 60 FPS로 렌더링됩니다.

델타 시간
    ▪프레임 사이에 경과하는 시간을 프레임 시간, 시간 델타 또는 델타 시간이라고 합니다.
    ▪델타 시간은 일반적이며 종종 기호 Δt로 수학적으로 표현됩니다.
        •게임이 정확히 30FPS로 렌더링되는 경우 델타 시간은 1/30초 또는 33.3ms입니다.
        •게임이 정확히 60FPS로 렌더링되는 경우 델타 시간은 1/60초 또는 16.6ms입니다.

프레임 속도에서 속도로
    ▪초당 40미터의 일정한 속도로 게임 세계를 비행하는 우주선을 만들고 싶다고 상상해 봅시다.
    ▪이를 달성하는 한 가지 간단한 방법은 선박의 속도 v에 한 프레임의 지속 시간 Δt를 곱하여 위치 변화 Δx= vΔt를 산출하는 것입니다.
    ▪다음 프레임에서 위치를 찾기 위해 이 델타 위치를 배의 현재 위치 x(t)에 추가할 수 있습니다.
        •x(t+1) = x(t) + Δx= x(t) + vΔt      
    ▪이것은 실제로 명시적 오일러 방법으로 알려진 수치 적분의 간단한 형태입니다. 

    의문:
        ▪프레임 번호 대신 Δt를 사용하는 이유는 무엇입니까?

CPU 종속 게임
    ▪많은 초기 비디오 게임에서는 게임 루프 동안 실제 시간이 얼마나 경과했는지 측정하려는 시도가 없었습니다.
    ▪프로그래머는 본질적으로 Δt를 모두 무시하고 대신 프레임당 미터로 개체의 속도를 직접 지정합니다.
    ▪이 단순한 접근 방식의 최종 효과는 이러한 게임에서 물체의 인식 속도가 특정 하드웨어에서 게임이 실제로 달성하는 프레임 속도에 전적으로 의존한다는 것입니다.
    ▪이러한 종류의 게임이 원래 작성된 시스템보다 CPU가 더 빠른 컴퓨터에서 실행되면 게임이 빨리 감기로 실행되는 것처럼 보입니다.
    
    => Δt를 무시하고, 프레임당 미터로 값을 계산했기에 컴퓨터의 cpu 속도가 빠르다면 게임이 빠르게 감기로 실행되는 것처럼 보인다.

경과 시간을 기준으로 업데이트
    ▪게임을 CPU 독립적으로 만들려면 어떤 방식으로든 Δt를 측정해야 합니다.
    ▪간단한 방법은 CPU의 고해상도 타이머 값을 두 번 읽는 것입니다. 한 번은 프레임 시작 부분에서, 한 번은 프레임 끝 부분에서 읽습니다.
    ▪그런 다음 빼서 방금 통과한 프레임에 대한 Δt의 정확한 측정값을 생성합니다.

경과 시간을 기준으로 업데이트
    ▪그러나 이러한 접근은 큰 문제를 안고 있다.
        •현재 프레임의 측정값을 다음 프레임의 델타 시간으로 사용하는 것이 정확하지 않습니다.
        •다음 프레임에 현재 프레임보다 훨씬 더 많은 시간이 소요되는 문제가 발생할 수 있습니다.
        •마지막 프레임의 델타를 다가오는 프레임의 추정치로 사용하면 매우 실질적인 해로운 영향을 미칠 수 있습니다.

프레임 속도 관리
    ▪ 우리는 머리에서 문제를 뒤집음으로써 마지막 프레임의 Δt를 이 프레임 지속 시간의 추정치로 사용하는 부정확성을 피할 수 있습니다.
    ▪ 다음 프레임의 지속 시간을 추측하는 대신 모든 프레임의 지속 시간이 정확히 33.3ms(30FPS에서 실행 중인 경우)가 되도록 보장할 수 있습니다.
        • 측정된 기간이 이상적인 프레임 시간보다 짧으면 대상 프레임 시간이 경과할 때까지 메인 스레드를 휴면 상태로 둡니다.
        • 측정된 지속 시간이 이상적인 프레임 시간보다 길면 전체 프레임을 건너뛸 수 있습니다.
    ▪ 장면에 그리기 비용이 많이 드는 오브젝트가 한 프레임에 많이 포함되어 있는 경우 다음 프레임에서 그 중 일부를 그리는 것이 좋습니다.
    ▪ 프레임 속도를 일정하게 유지하는 것이 중요할 수 있습니다.
        •물리 시뮬레이션을 일정한 속도로 업데이트하면 종종 최상의 결과를 얻을 수 있습니다.
        •기록 및 재생과 같은 기능은 경과된 프레임 시간이 일정할 때 훨씬 더 안정적입니다.

클록 클래스
    ▪일부 게임 엔진은 클록 변수를 클래스에 캡슐화합니다.
    ▪시계 클래스는 일반적으로 시계가 생성된 이후 경과된 절대 시간을 추적하는 변수를 포함합니다.
    ▪또한 시간 조정과 같은 멋진 기능도 지원할 수 있습니다.

화면 찢김 및 V-Sync
    ▪ 비디오 하드웨어에 의해 화면이 부분적으로만 "그려진" 상태에서 백 버퍼가 프런트 버퍼로 교체될 때 화면 찢김으로 알려진 시각적 이상 현상이 발생합니다.
    ▪ 티어링 발생 시 화면의 일부는 새로운 이미지로, 나머지는 기존 이미지로 보여집니다.
    ▪ 테어링을 방지하기 위해 많은 렌더링 엔진은 버퍼를 교환하기 전에 모니터의 수직 블랭킹 간격을 기다립니다.
    ▪ 오래된 CRT 모니터와 TV는 왼쪽에서 오른쪽으로, 위에서 아래로 스캔하는 전자 빔을 통해 화면의 형광체(형광체)를 자극하여 인메모리 프레임 버퍼의 내용을 그립니다.
        • 이러한 디스플레이에서 v-blank 간격은 전자총이 화면의 왼쪽 상단 모서리로 재설정되는 동안 블랭킹(꺼짐)되는 시간입니다.
    ▪ 현대식 LCD, 플라즈마 및 LED 디스플레이는 더 이상 전자 빈을 사용하지 않으며 한 프레임의 마지막 스캔 라인 그리기를 완료하고, 
       다음 프레임의 첫 번째 스캔 라인을 그리는 사이에 시간이 필요하지 않습니다.
        • 그러나 v-blank 간격은 여전히 존재합니다. 
         부분적으로는 CRT가 표준이었을 때 비디오 표준이 확립되었기 때문이고 부분적으로는 구형 디스플레이를 지원해야 하기 때문입니다.
    ▪ v-blank 간격을 기다리는 것을 v-sync라고 합니다.
        • 이것은 메인 게임 루프의 프레임 속도를 화면 새로 고침 속도의 배수로 효과적으로 고정하기 때문에 프레임 속도 관리의 또 다른 형태입니다.
        • 예를 들어 60Hz의 속도로 재생되는 NTSC 모니터에서 게임의 실제 업데이트 속도는 1/60초의 배수로 효과적으로 양자화됩니다.
        • 프레임 사이에 1/60초 이상이 경과하면 다음 v-blank 간격까지 기다려야 합니다. 즉, 2/60초를 기다려야 합니다.

클라이언트 서버
    ▪ 서버는 전용 시스템에서 실행 중일 수 있으며 이 경우 전용 서버 모드에서 실행 중이라고 합니다.
        • 그러나 클라이언트와 서버가 별도의 시스템에 있을 필요는 없으며 실제로 클라이언트 시스템 중 하나가 서버도 실행하는 것이 일반적입니다.
        • 사실 싱글 플레이어 게임 모드는 클라이언트가 하나만 있고 클라이언트와 서버가 모두 동일한 시스템에서 실행되는 타락한 멀티 플레이어 게임에 불과합니다.
        • 이것은 client-on-top-of-servermode로 알려져 있습니다.
    ▪ 클라이언트와 서버의 게임 루프는 개념적으로 별개의 개체이기 때문에 완전히 별개의 프로세스로 구현될 수 있습니다.
        • 그러나 클라이언트와 서버가 별도의 시스템에 있을 필요는 없으며 실제로 클라이언트 시스템 중 하나가 서버도 실행하는 것이 일반적입니다.
        • 결과적으로 많은 게임이 단일 게임 루프에서 서비스되는 단일 스레드에서 클라이언트와 서버를 모두 실행합니다.
    ▪클라이언트와 서버 코드가 서로 다른 속도로 업데이트될 수 있음을 인식하는 것이 중요합니다.
        •예를 들어 Quake에서 서버는 20FPS(프레임당 50ms)로 실행되는 반면 클라이언트는 일반적으로 60FPS(프레임당 16.6ms)로 실행됩니다.
        •이를 구현하기 위해 마지막 서버 업데이트 이후 경과된 시간을 추적하고 50ms에 도달하거나 초과하면 서버 프레임이 실행되고 타이머가 재설정됩니다.

피어 투 피어
    ▪ P2P 멀티플레이어 아키텍처에서 온라인 게임의 모든 머신은 서버와 클라이언트처럼 작동합니다.
        • 하나의 기계만이 게임의 각 동적 개체에 대한 권한을 가집니다. 따라서 각 시스템은 권한이 있는 개체에 대해 서버처럼 작동합니다.
        • 게임 세계의 다른 모든 객체에 대해 기계는 클라이언트처럼 작동하여 해당 객체의 원격 권한이 제공하는 모든 상태로 객체를 렌더링합니다.
        • 클라이언트-서버 모델에서는 일반적으로 어떤 코드가 서버에서 실행 중이고 어떤 코드가 클라이언트 측에 있는지가 매우 명확합니다.
          그러나 P2P 아키텍처에서는 두 가지 가능한 경우를 처리하도록 많은 코드를 설정해야 합니다. 원격 권한 있는 표현을 위한 멍청한 프록시일 뿐입니다.