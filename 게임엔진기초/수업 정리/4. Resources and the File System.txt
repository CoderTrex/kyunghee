7. 파일 시스템

파일 시스템 api
파일 시스템 api는 엔진 스패셜 api안에 있는 원시적인 api를  wrap을 한다.
-> 장점은 크로스 플랫폼에서 api를 원활하게 처리할 수 있음
-> 게임 엔진의 파일 시스템 api는 다른 대상 하드웨어 플랫폼 간의 차이점에서 보호 가음
-> 또한 os가 제공하지 않는 파일 시스템 api를 제공한다.

게임 엔진 파일 시스템 api아는 일반적으로 다음 지역을 기능적으로 다룬다.
-> 파일 이름과 경로
-> 열기 / 닫기 / 읽기 / 쓰기 -> 개별적인 파일에 대해서
-> 개별적인 디렉토리 내용 스캔
-> 비동기 파일의 i/o 요청 관리

파일 이름과 경로
경로는 문장 형태로 묘사되는 파일의 위치 또는 디렉토리 위치를 의미한다. -> 파일 시스템 종속성을 띄는
각각의 운영체제는 파일 시스템의 약간의 변주를 보인다.

unix :      '/'를 구분자로 사용한다.
max os :    ':'를 구분자로 사용한다. 
window :    ':'를 디스크 구분자로 사용한다.
            원격 컴퓨터 디스크립터는 '\\' 이후 '\'를 사용한다.

유닉스와 이것의 다양성은 볼륨을 지원하지 않는다. 
분리된 디렉토리 종속성을 때문에 유닉스의 경로는 볼륨지정자를 가지지 않는다.

dos와 초기 윈도우 버전에서는 파일은 8글자 이내여야 하며, 확장자는 3글자여야 했다.
:은 윈도우와 dos에서 드라이브 지정자로 밖에 사용 못함

콘솔은 특정한 지정자를 사용해서 디스크를 나타낸다. 
dev_dbvd를 통해서 블루레이 디스크를 나타내고
dev_hddx를 통해서 하나 이상의 하드 디스크를 나타낸다.

path vs search path

path        :  경로는 하나의 파일이나 디렉토리의 경로를 나타내는 게 사용됨
search path :  콜론이나 세미 콜론 같은 특별한 문자열로 구분되는 상대경로이다.

디렉토리를 다루기 위한 다양한 방법
• 디렉터리 격리
• 경로 정규화
• 절대경로와 상대경로 전환
• 파일명 또는 확장자 얻기

스텐다드 C 라이브러리는 파일 읽고 쓰기를 위한 2가지 api를 제공함
-> 버퍼와 언버퍼 방식

buffer api :
- 버퍼 i/o api는 데이터 블럭을 제공하는데 이것이 바로 버퍼이다. 
  프로그램과 디스크 위의 파일간의 바이트 전달 -> 소스의 방향으로서
- 바이트 바이 바이트 읽기 대신, 버퍼 결과 흐름은 버퍼들을 모와서 하나의 버퍼로 보낸다.
  os 파일 시스템은 데이터가 충분히 모이면 전달됨
- 가끔 이러한 타입의 api는 stream I/O api로 불린다. 왜나햐면 그들은 추상성을 제공한다. 
  이는 디스크 파일이 바이트의 흐름처럼 보이게 한다.
- 버퍼 I/O는 디렉토리 접근을 최소화 한다. 
- 파일 시스템 콜의 횟수를 줄인다.

unbuffer api :
- 버퍼화 되지 않은 결과는 프로그래머가 디스크에 많은 양의 시퀀스를 가지고 있을 때에
- 버퍼와 되지 않은 I/O는 보증하지 않는다. 
  데이터가 물리적 디스크에 접근했는지 여부에 대해서

synchronous file I/O : 
  스레드가 I/O를 I/O 요청이 끌날때 까지 다른 명령은 진행하지 않는다.

Asysynchronous file I/O : 
  많은 게임이 원활함을 제공하기 위해 스트리밍을 통한 
  스트리밍을하면서 게임이 진행되는 동안 다음 레벨에 대한 데이터를 진행함.
  스트리밍을 지원하기 위해서 우리는 i/o RUN time에 실시간으로 요청을 받아서 실행할 수 있음

priorities :
  - 동기화 i/o 운영체제는 다양한 우선순위를 가진다. 파일 i/o가 리얼타임인 이후부터
  - 예를 들어 하드에서 오디오 스트리밍 또는 블루레이와 하늘을 출력하고, 다음 오디오 버퍼를 로딩하는 것은
    게임 레벨의 청크와 텍스처를 출력하는 것보다 높은 우선순위를 가진다. 

  higher priorities:
  - streaming audio from the hard disk
  - Bluray and playing it on the fly
  - loading the next
  - buffer full of audio data  

  lower priorities:
  - loading a texture or a chunk of a game level.

Asysynchronous file I/O:
  - "Asysynchronous file I/O"는 스레드를 분리해 I/O를 관리한다.
  - 메인 스레드는 함수를 호출한다.  
  - 낮은 우선순위의 작업은 늦추고 높은 우선순위의 작업을 먼저 수행해서 각자의 데드라인을 맞출 수 있음
  - 작업중에 다른 콜이 들어오면 block으로 작업을 제한한다.
  - 요청이 완료되면, callback이 실행되는데 메인 스레드의 호출로 발생한다.
    그러므로 작동이 완료된 것을 공지한다.

stack 베이스 게임 
  1. global 자원 먼저 할당됨
  2. 탑의 위치 마킹됨, 이 포지션이 free 될 수 있게 하기 위해서
  3. 레벨을 로드해서 우리가 자원을 stack에 쉽게 할당함
  4. 레벨이 마무리되면 우리는 쉽게 전에 마킹한대로 이동할 수 있음

  2개의 스텍 사용
  낮은 스택이 영구적인 데이터 사용을 나타냄
  높은 위치의 스텍은 동적인 메모리 할당을 진행함

pool-base resource allocation :
  동일한 사이즈의 chunk로 나누어서 자원을 할당함
  청크의 사이즈는 동일하기에 pool-allocater 를 이용해 할당이 가능함
  또한 동일하기에 메모리 누수가 나지않음
  동일한 사이즈로 모든 데이터가 나뉠 수 있어야 함

  chunk의 사이즈보다 작은 데이터가 할당되면, 빈공간의 청크는 활용되지 않는다.
  일반적인 chunk의 크기는 몇 키로바이트 이다.

  낭비되는 청크 메모리공간을 해결하기 위해서 우리는 특별 메모리를 사용할 수 있다.
  -> 리소스 청크 할당자라고 부른다.
  이것을 보충하기 위해서 우리는 프리해야하는 블락의 위치와 사이즈를 알아야 한다.

  불행하게도 문제점이 있다.
  -> 만약에 사용하지 않은 공간에 청크를 할당한다면, 우리는 청크가 프리해야할 때 프리가 불가능하다.
  -> 간단한 해결법은 연관되어 있는 리소스 끼리 묶어서 활용하는 것이다.

  풀안의 각각의 청크는 특정 게임의 레벨과 연관되어 있음 (연결리스트로 구현됨)
  다른 주기를 가진 다양한 레벨의 동시성 메모리에 있다.

복합 리소스와 참조 무결성:
  일반적으로 게임의 자원 데이타 베이스는 다양한 리소스 파일들로 구성되어 있다. 각각의 파일은 하나나 여러개의 데이터를 오브젝트를 포함한다.
  이 데이터들은 임의의 방식으로 서로를 참조하고, 의존한다.
  -> 예를 들어, 메쉬 데이터 구조는 메터리얼의 참조를 가지는데 이는 텍스터에 대한 참조 목록을 가지고 있다.

  일반적으로 상호 참조는 종속성을 의미합니다.

  단일 파일 내의 두 개체 간의 참조는 내부 상호 참조입니다.
  다른 파일에 있는 두 개체 간의 참조는 외부 상호 참조 입니다.


  복합 자원이라는 용어를 사용하여 상호 의존적인 자원의 자급자족 클러스터를 설명합니다.

  모델은 하나 이상의 삼각형 메쉬, 선택적 스켈레톤 및 선택적 애니메이션 모음으로 구성된 복합 리소스입니다.
  3D 모델과 같은 복합 리소스를 메모리에 완전히 로드하려면 모든 종속 리소스도 로드해야 합니다.

자원간의 상호 참조 처리
  자원 매니저는 서로간의 참조를 관리하면서, 각 자원의 무결성을 유지해야 하는데 이것은 상당히 업려다..
  c++에서 2개의 데이터간의 참조는 포인터나 래퍼런스로 이루어진다. 
  -> 하지만 포인터는 단순히 메모리 주소이다. -> 때문에 실행 어플리케이션의 문맥을 벗어나면, 그들은 의미를 잃는다.
  가장 좋은 접근은 상호 참조를 참조된 개체의 고유 iD를 포함한 문자열 또는 해쉬코드로 저장하는 것이다.
  - GUID를 가져야 한다.
  - 런타임 리소스 메니저는 글로벌 자원 look-up 테이블을 가지고 있어야 한다.
  - 데이터가 조회될 때마다, GUID에 look-up키가 저장이 된다.
  - 모든 리소스 개체가 메모리에 로드된 후 각 상호 참조 개체의 주소를 조회하여 모든 개체에 대한 패스를 만들 수 있습니다.

데이터 개체를 이진 파일에 저장할 때 자주 사용되는 또 다른 방법
=> 포인터를 파일 오프셋으로 변환하는 것입니다.
  • 포인터를 통해 서로를 상호 참조하는 C 또는 C++ 개체 그룹을 고려하십시오.
  • 이 객체 그룹을 이진 파일에 저장하려면 임의의 순서로 각 객체를 한 번만 방문하고 각 객체의 메모리 이미지를 순차적으로 파일에 써야 합니다(직렬화된 데이터).

  • 메모리 이미지가 RAM에서 연속적이지 않은 경우에도 객체를 파일 내 연속 이미지로 직렬화하는 효과가 있습니다.
  • 개체의 메모리 이미지가 이제 파일 내에서 연속적이기 때문에 파일 시작 부분에 상대적인 각 개체 이미지의 오프셋을 결정할 수 있습니다.
  • 이진 파일 이미지를 작성하는 과정에서 모든 데이터 개체 내의 모든 포인터를 찾고 각 포인터를 오프셋으로 변환한 다음 해당 오프셋을 포인터 대신 파일에 저장합니다.

  • 파일의 이진 이미지가 로드되면 이미지에 포함된 개체가 연속 레이아웃을 유지하므로 오프셋을 포인터로 변환하는 것이 간단합니다. 
    파일 이미지 전체의 주소에 오프셋을 추가하기만 하면 됩니다.

사후 로드 초기화
  이상적으로는 모든 리소스가 오프라인 도구로 완전히 준비되어 메모리에 로드되는 순간 사용할 준비가 됩니다.
  실제로 이것이 항상 가능한 것은 아닙니다. 많은 유형의 리소스는 로드된 후 엔진에서 사용할 수 있도록 준비하기 위해 약간의 "마사지"가 필요합니다.
  로드 후 초기화라는 용어는 리소스 데이터가 로드된 후의 모든 처리를 의미합니다.

  사후 로드 초기화는 일반적으로 다음 두 가지 종류 중 하나로 제공됩니다.
  • 경우에 따라 사후 로드 초기화는 피할 수 없는 단계입니다. 
    예를 들어 PC에서 3D 메시를 설명하는 정점과 인덱스는 기본 RAM에 로드되지만 렌더링되기 전에 GPU RAM으로 전송되어야 합니다. 
    이것은 다이렉트 X 버텍스 버퍼 또는 인덱스 버퍼를 생성하고, 잠그고, 데이터를 버퍼로 복사하거나 읽은 다음 
    잠금을 해제함으로써 런타임에만 수행할 수 있습니다.
  • 다른 경우에는 로드 후 초기화 중에 수행되는 처리를 피할 수 있지만(즉, 도구로 이동할 수 있음) 편의를 위해 수행됩니다. 
    예를 들어 프로그래머는 정확한 호 길이 계산을 엔진의 스플라인 라이브러리에 추가할 수 있습니다. 
    아크 길이 데이터를 생성하기 위해 도구를 수정하는 데 시간을 소비하는 대신 프로그래머는 로드 후 초기화 중에 런타임에 간단히 계산할 수 있습니다. 
    나중에 계산이 완료되면 이 코드를 도구로 옮길 수 있으므로 런타임에 계산을 수행하는 비용을 피할 수 있습니다.