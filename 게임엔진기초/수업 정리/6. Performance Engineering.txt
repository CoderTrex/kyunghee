데나드 스케일링
    트랜지스터가 작아질수록 전력밀도가 일정하게 유지되어 전력 사용양이 면적 비례하게 유지된다는 법칙을 의미함.
    ▪2007년경에 이 전략은 누수 효과로 인해 작동을 멈췄습니다.
    •회로 기능이 너무 작아서 자기장이 이웃 회로의 전자를 예상하지 못한 방향으로 움직이게 하여 불필요한 가열과 가끔 비트 플립핑을 유발합니다.
    ▪이를 완화하는 유일한 방법은 전압을 높이는 것입니다.
        • 그런 다음 전력 소비의 균형을 맞추기 위해 클록 주파수를 줄여야 합니다. 
          그러면 트랜지스터 밀도가 증가함에 따라 전체 프로세스의 수익성이 점차 낮아집니다.
        • 어떤 시점에서 클록 속도는 스케일링으로 더 이상 증가할 수 없었고 소형화 추세가 둔화되기 시작했습니다.

현대 컴퓨팅
    ▪클럭 속도는 안정되었지만 트랜지스터 수는 여전히 증가하고 있어 새로운 병렬 하드웨어를 생성할 수 있습니다.
        • 더 빠른 주기를 쫓는 대신 CPU 설계는 단일 주기에서 더 유용한 작업을 수행하는 데 집중하기 시작했습니다.
        • 트랜지스터는 작아지는 대신 모양이 바뀌고 있습니다.
        ▪ 이로 인해 사이클마다 수십, 수백 또는 수천 가지의 다른 작업을 수행할 수 있는 점점 더 복잡한 아키텍처가 생겼습니다.

명령어 파이프라이닝
    ▪명령을 실행하기 위해 프로세서는 먼저 많은 준비 작업을 수행해야 합니다. 여기에는 다음이 포함됩니다.
        •Fetching : 메모리에서 기계어 코드 덩어리.
        •디코딩 : 그것을 명령어로 나누는 것.
        •Executing : 일부 메모리 작업 수행을 포함할 수 있는 이 명령어.
        •Writing : 결과를 레지스터로 되돌립니다.

명령어 파이프라이닝
    ▪ 이 전체 작업 순서는 길다.
    ▪ 두 개의 레지스터에 저장된 값을 함께 더하는 것과 같은 간단한 작업에도 최대 15-20 CPU 사이클이 소요됩니다.
    ▪ 이 대기 시간을 숨기기 위해 최신 CPU는 파이프라이닝을 사용합니다. 
      명령이 첫 번째 단계를 통과한 후 이전 단계가 완전히 완료될 때까지 기다리지 않고 바로 다음 단계를 처리하기 시작합니다.


파이프라인 위험
    ▪ 파이프라이닝을 사용하면 명령을 동시에 실행하여 지연 시간을 숨길 수 있지만 고유한 몇 가지 잠재적인 장애물
      (특징적으로 파이프라인 위험이라고 함, 즉 다음 명령이 다음 클록 주기에서 실행될 수 없는 상황)이 생성됩니다.
    ▪ 이러한 상황이 발생할 수 있는 여러 가지 방법이 있습니다.
        • 구조적 위험은 두 개 이상의 명령어가 CPU의 동일한 부분(예: 실행 장치)을 필요로 할 때 발생합니다.
        • 이전 단계에서 피연산자가 계산될 때까지 기다려야 할 때 데이터 해저드가 발생합니다.
        • 제어 위험은 CPU가 다음에 실행해야 하는 명령을 알 수 없을 때 발생합니다.
    ▪ 다른 위험에는 다른 문제점이 있습니다.
        • 구조적 위험에서는 실행 장치가 준비될 때까지 기다려야 합니다(보통 한 주기 더). 
          이는 성능의 근본적인 병목 현상이며 피할 수 없습니다. 주변을 엔지니어링해야 합니다.
        • 데이터 해저드에서는 필요한 데이터가 계산될 때까지 기다려야 합니다(주요 경로의 대기 시간). 
          데이터 위험은 임계 경로가 더 짧아지도록 계산을 재구성하여 해결됩니다.
        • 제어 위험에서는 일반적으로 전체 파이프라인을 세척하고 다시 시작해야 하므로 전체 15-20 사이클이 낭비됩니다. 
          분기를 완전히 제거하거나 CPU가 다음에 실행될 항목을 효과적으로 추측할 수 있도록 분기를 예측 가능하게 만들어 해결합니다.

분기 비용
    ▪ CPU가 조건부 점프 또는 다른 유형의 분기를 만나면 조건이 계산될 때까지 유휴 상태로 있지 않고 
      즉시 수행될 가능성이 더 높은 것으로 보이는 분기를 예측적으로 실행하기 시작합니다.
    ▪ 실행 중에 CPU는 각 명령에서 수행된 분기에 대한 통계를 계산하고 일정 시간이 지나면 공통 패턴을 인식하여 이를 예측하기 시작합니다.
    ▪ 이러한 이유로 분기의 진정한 "비용"은 CPU가 얼마나 잘 예측할 수 있는지에 크게 좌우됩니다. 순수한 50/50 동전 던지기인 경우 제어 위험을 겪고,
      전체 파이프라인을 폐기해야 하며 다시 구축하는 데 15-20 사이클이 더 걸립니다. 
      그리고 분기가 항상 또는 전혀 사용되지 않는 경우 조건을 확인하는 것 외에는 거의 아무것도 지불하지 않습니다.


분기 없는 프로그래밍
    ▪ CPU에서 효과적으로 예측할 수 없는 분기는 분기가 잘못 예측한 후 새 명령을 가져오는 데 
      긴 파이프라인 지연을 유발할 수 있으므로 비용이 많이 듭니다.
    ▪ 이를 최적화하려면 조건문을 제거해야 합니다.
        • 단, 프로그램의 불가피한 부분이다.
        • 따라서 모든 시나리오를 최적화할 수 있는 것은 아닙니다.
        • 경우에 따라 분기를 교체하면 성능이 저하되고 추가 지침이 추가될 수 있습니다.