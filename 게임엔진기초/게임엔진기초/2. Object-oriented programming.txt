++게임 업계의 프로그래밍 언어
    ▪C++은 게임 업계에서 가장 많이 사용되는 언어이기 때문에 이번 강의에서는 주로 C++에 대해 집중적으로 다루도록 하겠습니다.
    ▪그러나 게임 산업에서는 다른 많은 언어도 사용됩니다.
        •명령어: C
        •객체 지향 언어: C# 및 Java
        •스크립팅 언어: Python, Lua 및 Perl
        •기능적 언어: Lisp, Scheme 및 F#

게임 업계의 프로그래밍 언어
    ▪모든 프로그래머는 적어도 두 가지 고급 언어와 어셈블리 언어를 배울 것을 권장합니다.
    ▪저수준 언어:
        •저수준 언어는 일반적으로 컴퓨터의 명령 집합(명령, 기능 등)에서 추상화를 거의 또는 전혀 제공하지 않습니다.
        •저수준 언어는 엔지니어가 메모리 관리를 처리해야 합니다.
        • C 언어는 저수준으로 간주되지만 진정한 저수준 언어는 어셈블리 및 기계 코드입니다.

다른 언어에 비해 C++의 장점은 다음과 같습니다[C++].
    ▪ 결정적입니다(무엇이 언제 실행될지 결정할 수 있음). 
      이것은 가비지 수집된 언어에는 해당되지 않으며 가상 머신에서 실행되는 언어에 대해서는 (또는 부분적으로) 해당되지 않습니다.
    ▪ 높은 성능을 제공합니다(C와 유사한 성능을 얻을 수 있으며 원하는 경우 일부 어셈블리 코드를 추가할 수도 있음).
    ▪ 다른 빠른 언어(예: C)보다 높은 수준의 추상화를 제공합니다.
    ▪클래스는 유용하고 의미 있는 전체를 함께 형성하는 속성(데이터) 및 동작(코드)의 모음입니다.
    ▪클래스는 개체로 알려진 클래스의 개별 인스턴스가 구성되는 방법을 설명하는 사양입니다.
    ▪예를 들어, 당신의 펫 '토끼 나란히듀'는 '플레이어 캐릭터' 클래스의 인스턴스입니다.

캡슐화
    ▪ 캡슐화는 객체가 외부 세계에 제한된 인터페이스만 제공한다는 것을 의미합니다. 
    개체의 내부 상태 및 구현 세부 정보는 숨겨진 상태로 유지됩니다.
    ▪ 캡슐화는 잠재적으로 복잡한 구현 세부 사항이 아니라 클래스의 제한된 인터페이스만 이해하면 되므로 프로그래머의 삶을 단순화합니다.

다중 상속
    ▪ 일부 언어는 MI(다중 상속)를 지원합니다. 즉, 클래스는 하나 이상의 부모 클래스를 가질 수 있습니다.
    ▪ 이론적으로 MI는 매우 우아할 수 있지만 실제로 이러한 종류의 디자인은 일반적으로 많은 혼란과 기술적 어려움을 야기합니다.
    ▪ MI는 간단한 클래스 트리를 잠재적으로 복잡한 그래프로 변환합니다.
    ▪ "다이아몬드 문제"는 두 클래스 B와 C가 A를 상속하고 클래스 D가 B와 C를 모두 상속할 때 발생하는 모호성입니다.
        • GUI 컨텍스트에서 Button 클래스는 Rectangle(외관용) 및 Clickable(기능용) 클래스 모두에서 상속할 수 있습니다.
        • Rectangle 및 Clickable 클래스는 모두 Objectclass에서 상속됩니다.
        • Button 객체에 대해 equals 메소드가 호출되고 Button 클래스에는 그러한 메소드가 없지만 Rectangle 
          또는 Clickable에 재정의된 equals 메소드가 있는 경우 결국 호출해야 하는 메소드는 무엇입니까?

다중 상속
    ▪ 대부분의 C++ 소프트웨어 개발자는 다중 상속을 완전히 피하거나 제한된 형식으로만 허용합니다.
    ▪ A Mixini는 특별한 종류의 다중 상속입니다.
        • mixin class는 원하는 기능을 포함하는 상위 클래스 역할을 합니다.
        • 하위 클래스는 이 기능을 상속하거나 단순히 재사용할 수 있습니다.
        • 일반적으로 mixin은 엄격한 단일 "is a" 관계를 생성하지 않고 원하는 기능을 자식 클래스로 내보냅니다.
    ▪Mixin은 다음과 같은 몇 가지 이점을 제공합니다.
        •다중 상속의 복잡한 의미 없이 하나의 클래스가 여러 클래스의 공통 기능을 사용할 수 있도록 하여 다중 상속 메커니즘을 제공합니다.
        •코드 재사용을 장려합니다. 동일한 코드를 반복해서 반복하는 대신 공통 기능을 믹스인으로 그룹화한 다음 이를 필요로 하는 각 클래스에 포함할 수 있습니다.
        •반드시 상위 클래스의 모든 기능이 아니라 상위 클래스에서 원하는 기능만 상속 및 사용하는 혼합을 허용합니다.
다형성
    ▪ 다형성(Polymorphism)은 하나의 공통 인터페이스를 통해 다른 유형의 개체 모음을 조작할 수 있도록 하는 언어 기능입니다.
    ▪ 예를 들어, 2D 페인팅 프로그램은 화면에 그릴 다양한 모양의 목록을 제공받을 수 있습니다.
    ▪ 이러한 이질적인 도형 모음을 그리는 한 가지 방법은 switch 문을 사용하여 각 고유한 도형 유형에 대해 서로 다른 그리기 명령을 수행하는 것입니다.
    ▪ 이 접근법의 문제점은 drawShapes() 함수가 그릴 수 있는 모든 종류의 도형에 대해 알아야 한다는 것입니다.
    ▪ 간단한 예에서는 괜찮지만 코드의 크기와 복잡성이 커지면 시스템에 새로운 유형의 도형을 추가하기가 어려워질 수 있습니다.
    ▪ 새로운 모양 유형이 추가될 때마다 모양 유형 세트에 대한 지식이 포함된 코드 베이스의 모든 위치를 찾고 새 유형을 처리하기 위한 사례를 추가해야 합니다.
    ▪ 해결책은 다룰 수 있는 개체 유형에 대한 지식으로부터 대부분의 코드를 분리하는 것입니다.
    ▪ 이를 달성하기 위해 지원하려는 각 유형의 도형에 대한 클래스를 정의할 수 있습니다.
    ▪ 이러한 모든 클래스는 공통 기본 클래스인 Shape에서 상속됩니다.
    ▪ Draw()라는 가상 함수가 정의되고 각 모양 클래스는 이 함수를 다른 방식으로 구현합니다.
    ▪ 주어진 도형의 특정 유형을 알지 못하더라도 그리기 함수는 이제 각 도형의 Draw() 함수를 차례로 호출할 수 있습니다.

구성 및 집계
    ▪ 컴포지션은 단순한 것에서 복잡한 것을 만드는 과정입니다.
        • 컴포지션은 클래스 간에 "소유" 관계를 생성합니다.
        • "나는 객체를 소유하고 있으며 그 수명에 대해 책임이 있습니다."
    ▪ 집계는 한 클래스가 다른 클래스를 엔티티 참조로 정의하는 프로세스입니다.
        • 집계는 클래스 간에 "has-a" 관계를 생성합니다.
        • “다른 사람에게서 빌린 물건이 있습니다. 내가 죽어도 개체는 계속 살아있을 수 있습니다.”

디자인 패턴
    ▪ 동일한 유형의 문제가 반복해서 발생하고 많은 다른 프로그래머가 해당 문제에 대해 매우 유사한 솔루션을 사용하는 경우 디자인 패턴이 발생했다고 말합니다.
    ▪ 객체 지향 프로그래밍에서 다양한 작성자가 여러 가지 일반적인 디자인 패턴을 식별하고 설명했습니다.
        • 싱글톤(Singleton): 이 패턴은 특정 클래스가 하나의 인스턴스만 갖도록 보장하고 이에 대한 글로벌 액세스 지점을 제공합니다. 
                            싱글톤은 일반적으로 고유한 리소스를 캡슐화하고 애플리케이션 전체에서 쉽게 사용할 수 있도록 합니다. 
                            리소스는 하드웨어, 네트워크 서비스, 영구 저장소 또는 고유한 개체나 서비스로 모델링할 수 있는 모든 것일 수 있습니다.

현장에서의 OOP 예시
    ▪ 이미 '무기' 클래스가 있다고 가정합니다. 
        •손상, 내구도 등
    ▪ 사용자의 '무기' 데미지에 따라 몬스터의 체력을 줄이는 게임 로직도 구현했다고 가정합니다.
    ▪ 그러면 다른 프로그래머가 무기 클래스와 게임 로직의 세부 사항을 고려하지 않고 창, 검, 샛별과 같은 다양한 유형의 무기를 정의할 수 있습니다.
        • 변수(손상, 내구성 등)만 입력합니다.

C++ 전처리기
	전처리기는 C++ 코드가 컴파일러에 전달되기 전에 예비 작업을 수행합니다.
		▪전처리기는 헤더 파일, 매크로 확장, 조건부 컴파일 및 라인 제어를 포함하는 기능을 제공합니다.

전처리는 다음 네 단계로 시작됩니다.
    ▪삼자 대체: 전처리기는 삼자 시퀀스를 나타내는 문자로 바꿉니다. (예: ??( = [, ??! = | )
    ▪라인 스플라이싱: 이스케이프된 줄바꿈 시퀀스로 연속되는 물리적 소스 라인은 논리적 라인을 형성하기 위해 스플라이싱됩니다.
    ▪토큰화: 전처리기는 결과를 전처리 토큰과 공백으로 나눕니다. 주석을 공백으로 바꿉니다.
    ▪매크로 확장 및 지시어 처리: 파일 포함 및 조건부 컴파일을 포함한 전처리 지시어 라인이 실행됩니다. 
                                 전처리기는 동시에 매크로를 확장하고 C 표준의 1999 버전 이후로 handles_Pragmaoperators


