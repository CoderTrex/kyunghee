**게임 엔진?**
▪게임 엔진은 집약적인 프로그래밍 기술과 컴퓨팅 리소스 없이도 고품질 게임을 쉽고 빠르게 개발할 수 있는 새로운 방법입니다.
▪3D 게임 엔진은 게임 개발자가 엔진의 가용 기능을 사용할 수 있으므로 게임 회사의 비용, 시간 및 인력을 줄이는 데 도움이 됩니다.

**런타임 엔진 아키텍처**
게임 엔진은 일반적으로 도구 모음과 런타임 구성 요소로 구성됩니다.
▪다음 그림은 일반적인 3D 게임 엔진을 구성하는 모든 주요 런타임 구성 요소를 보여줍니다.
▪모든 소프트웨어 시스템과 마찬가지로 게임 엔진은 '계층'으로 구축됩니다.
▪일반적으로 상위 계층은 하위 계층에 종속되지만 그 반대는 아닙니다.

**-HardwareTarget 하드웨어**

▪대상 하드웨어 계층은 게임이 실행될 컴퓨터 시스템 또는 콘솔을 나타냅니다.
▪일반적인 플랫폼에는 Microsoft Windows, Linux 및 MacOS 기반 PC가 포함됩니다.
▪모바일 플랫폼에는 Apple iPhone, iPad, Android 스마트폰 및 태블릿이 포함됩니다.

**-DriversDevice 드라이버**

▪장치 드라이버는 운영 체제 또는 하드웨어 공급업체에서 제공하는 하위 수준 소프트웨어 구성 요소입니다.
▪드라이버는 하드웨어 리소스를 관리하고 사용 가능한 다양한 하드웨어 장치와의 통신 세부 정보로부터 운영 체제 및 상위 엔진 계층을 보호합니다.

**-OS운영 체제**

▪운영 체제(OS)는 항상 실행 중입니다.
▪하나의 컴퓨터에서 여러 프로그램의 실행을 조율합니다. 그 중 하나가 게임입니다.
▪Microsoft Windows와 같은 운영 체제는 실행 중인 여러 프로그램과 하드웨어를 공유하기 위해 시분할 접근 방식을 사용합니다.
▪이는 PC 게임이 하드웨어를 완전히 제어할 수 없음을 의미합니다. 시스템의 다른 프로그램과 원활하게 플레이해야 합니다.

**▪콘솔에서 운영 체제는 종종 게임 실행 파일로 직접 컴파일되는 얇은 라이브러리 계층일 뿐입니다. 게임은 일반적으로 전체 시스템을 '소유'합니다.
▪단, Xbox 및 Playstation 시리즈는 게임 실행을 중단하거나 특정 시스템 리소스를 차지할 수 있습니다.**

**- 3rd party SDK** 

3rd party SDK and middleware

▪대부분의 게임 엔진은 여러 타사 소프트웨어 개발 키트(SDK) 및 미들웨어를 활용합니다.
▪그래픽 (Graphic)

• OpenGL: 2D 및 3D 벡터 그래픽을 렌더링하기 위한 교차 언어 API입니다. API는 일반적으로 하드웨어 가속 렌더링을 달성하기 위해 그래픽 처리 장치(GPU)와 상호 작용하는 데 사용됩니다.
• libgcm: 이것은 playStation3의 RSX 그래픽 하드웨어에 대한 낮은 수준의 직접 인터페이스입니다.

• DirectX: 이것은 Microsoft의 3D 그래픽 SDK이며 OpenGL의 주요 경쟁자입니다.
• Vulkan: 오버헤드가 낮은 교차 플랫폼 API입니다. 이는 이전 API(OpenGL 및 Direct3D 11)보다 애플리케이션에 훨씬 낮은 수준의 API를 제공하는 것을 목표로 합니다.

▪데이터 구조 및 알고리즘

•STL: 이것은 데이터 구조, 문자열 및 스트림 기반 I/O 를 관리하기 위한 풍부한 코드와 알고리즘을 제공하는 c++ 표준 템플릿 라이브러리입니다.
•Boost++: 이것은 선형 대수, 유사 난수 생성, 멀티스레딩, 이미지 처리 등과 같은 작업 및 구조에 대한 지원을 제공하는 C++ 프로그래밍 언어용 라이브러리 세트입니다.
•Loki: Loki는 강력한 일반 프로그래밍 템플릿 라이브러리입니다.

▪충돌과 물리

•Havok: 널리 사용되는 강력한 물리 및 충돌 엔진입니다.
•PhysX: NVIDIA에서 제공하는 또 다른 인기 있는 강력한 물리 및 충돌 엔진입니다.

▪캐릭터 애니메이션

•Granny: 여기에는 강력한 3D 모델 및 애니메이션 내보내기가 포함됩니다.

•Spine: Spine은 게임용 2D 골격 애니메이션 소프트웨어입니다.
•Havok 애니메이션: Havok 회사는 이전보다 훨씬 쉽게 물리 애니메이션 격차를 해소할 수 있는 무료 애니메이션 SDK를 만듭니다.

**- 플랫폼 독립 계층** 

**대부분의 게임 엔진은 둘 이상의 하드웨어 플랫폼에서 실행할 수 있어야 한다 :**

▪일반적으로 대부분의 게임 스튜디오는 가능한 가장 큰 시장에 게임을 노출하기 때문에 다양한 플랫폼에서 게임을 대상으로 합니다.
▪따라서 대부분의 게임 엔진은 플랫폼 독립 계층으로 구성됩니다.

▪이 계층은 기본 플랫폼에 대한 대부분의 지식으로부터 엔진의 나머지 부분을 보호합니다.
▪이 계층은 모든 하드웨어 플랫폼에서 일관된 동작을 보장합니다.

**delegation (사용자 정의) :** 

▪객체 지향 프로그래밍에서 위임은 다른 원래 객체(발신자)의 맥락에서 한 객체(수신자)의 구성원을 평가하는 것을 말합니다.
▪송신 객체를 수신 객체로 전달하여 명시적으로 위임할 수 있습니다.
▪암시적 위임은 기능에 대한 언어 지원이 필요한 언어의 구성원 조회 규칙에 의해 수행될 수 있습니다(kotlin 참조).

**wrapper function (래퍼 기능) :** 

▪Wrapper 함수는 위임 수단입니다.
▪많은 라이브러리 함수는 시스템 호출 추상화를 위한 인터페이스 역할을 합니다.
▪가장 일반적으로 사용되는 표준 C 라이브러리 함수, 운영 체제 호출 및 기타 기본 API(Application Programming Interface)를 래핑함으로써 플랫폼 독립 계층은 모든 하드웨어 플랫폼에서 일관된 동작을 보장합니다.

**- core system :**

▪복잡한 게임 엔진에는 유용한 소프트웨어 유틸리티가 많이 필요합니다.
▪'핵심 시스템'이라는 레이블로 분류됩니다.

▪assertions

• 어설션은 프로그래머의 원래 가정에 대한 논리적 실수와 위반을 포착하기 위해 삽입되는 오류 검사 코드 라인입니다.

▪메모리 관리

•거의 모든 게임 엔진은 고속 할당 및 할당 해제를 보장하고 메모리 단편화의 부정적인 영향을 제한하기 위해 고유한 맞춤형 메모리 할당 시스템을 구현합니다.

▪math library

• 게임은 매우 수학 집약적입니다.
• 이와 같이 모든 게임 엔진에는 적어도 하나의 수학 라이브러리가 있습니다.
• 이 라이브러리는 벡터 및 행렬 수학, 쿼터니언 회전, 삼각법, 선, 광선, 구, 절두체 등을 사용한 기하학적 연산을 위한 기능을 제공합니다.

▪사용자 지정 데이터 구조 및 알고리즘

•게임 엔진은 기본 데이터 구조(연결된 목록, 동적 배열, 이진 트리, 해시 맵 등) 및 알고리즘(검색, 정렬 등)을 관리하기 위한 도구 모음이 필요한 경우가 많습니다.
•동적 메모리 할당을 최소화하거나 제거하고 대상 플랫폼에서 최적의 런타임 성능을 보장하기 위해 손으로 코딩하는 경우가 많습니다.

**- resource manager :**

▪리소스 관리자는 모든 유형의 게임 자산 및 기타 엔진 입력 데이터에 액세스하기 위한 통합 인터페이스(또는 인터페이스 모음)를 제공합니다.
▪일부 엔진(Unreal의 패키지, OGRE의 Resource-Manager 클래스)은 고도로 중앙 집중화되고 일관된 방식으로 이 작업을 수행합니다.
▪다른 엔진은 임시 접근 방식을 취하여 종종 게임 프로그래머가 디스크 또는 압축된 아카이브 내에서 원시 파일에 직접 액세스하도록 합니다.

**- 렌더링 엔진**

화면에 사물 그리기

▪렌더링 엔진은 모든 게임 엔진 중에서 가장 크고 복잡한 구성 요소 중 하나입니다.
▪화면에 텍스트, 이미지, 메쉬를 그립니다.

저수준 렌더러

▪저수준 렌더러는 엔진의 모든 원시 렌더링 기능을 포함합니다.
▪디자인은 장면의 어느 부분이 보일 수 있는지에 대해 크게 고려하지 않고 가능한 한 빠르고 풍부하게 기하학적 프리미티브 컬렉션을 렌더링하는 데 중점을 둡니다.

▪그래픽 장치 인터페이스

• 이것은 DirectX 및 OpenGL과 같은 그래픽 SDK를 처리합니다. 이 SDK는 사용 가능한 그래픽 장치를 열거하고, 초기화하고, 렌더링 표면을 설정하는 등의 목적으로 상당한 양의 코드를 작성해야 합니다.
•PC 게임 엔진의 경우 렌더러를 Windows 메시지 루프 또는 키보드 폴링 루프와 통합하기 위한 코드도 필요합니다.

▪기하학적 프리미티브 제출

•메시, 라인 목록, 포인트 목록, 입자, 지형 패치, 텍스트 문자열 등과 같은 렌더 패킷이라고도 합니다.

▪뷰포트 및 가상 화면

•Renderer는 일반적으로 뷰 필드와 근거리 및 원거리 클립 평면의 위치와 같은 관련 카메라-세계 매트릭스 및 3D 프로젝션 매개변수와 함께 뷰포트 추상화를 제공합니다.

▪정적 및 동적 조명

•제출된 각 프리미티브는 재료와 연관되며 조명의 영향을 받습니다.

**▪**텍스처 및 표면 관리

•재료는 물체의 광학적 특성(색상, 흐릿함, 광택 등)을 정의합니다.
•질감이란 대상을 칠하기 위한 패턴이나 이미지이다.



**- scene optimization (장면 최적화) :**

장면 그래프/컬링 최적화

▪저수준 렌더러는 해당 지오메트리가 실제로 표시되는지 여부에 관계없이 제출된 모든 지오메트리를 그립니다.
▪어떤 형태의 가시성 결정에 따라 렌더링을 위해 제출되는 프리미티브의 수를 제한하기 위해 일반적으로 더 높은 수준의 구성 요소가 필요합니다.

▪Frustum cull 및 공간 세분화.(안 보이는 위치의 데이터는 처리하지 않는다)

• 절두체 컬링은 카메라가 볼 수 없는 객체를 제거합니다.
•공간 세분화는 객체의 잠재적으로 보이는 세트(PVS)를 매우 빠르게 결정할 수 있도록 하여 렌더링 효율성을 향상시킵니다.

▪Frustum cull 및 공간 세분화

• 공간 분할은 이진 공간 분할 트리, 쿼드트리, 옥트리, kd-트리 또는 구 계층을 포함하여 다양한 형태를 취할 수 있습니다.

▪세부 수준•세부 수준(LOD)은 3D 모델 표현의 복잡성을 나타냅니다.

•모델이 보는 사람에게서 멀어지거나 개체 중요도, 관점 관련 속도 또는 위치와 같은 다른 메트릭에 따라 LOD가 감소할 수 있습니다.
•LOD 기술은 그래픽 파이프라인 단계의 작업 부하를 줄여 렌더링 효율성을 높입니다.

**- 시각 효과시각 효과**

▪최신 게임 엔진은 다음과 같은 다양한 시각 효과를 지원합니다.

•파티클 시스템(연기, 불, 물 튀김 등)
•데칼 시스템(총알 구멍, 발자국 등)
•조명 매핑 및 환경 매핑
•동적 그림자•전체 화면 사후 효과, 3D 장면이 오프스크린 버퍼로 렌더링된 후 적용됩니다. 

➢HDR(높은 동적 범위) 톤 매핑 및 블룸 

➢FSAA(전체 화면 안티 앨리어싱) 

➢블리치 바이패스, 채도 및 불포화 효과 등을 포함한 색상 보정 및 색상 전환 효과

▪파티클 및 데칼 시스템은 일반적으로 렌더링 엔진의 개별 구성 요소이며 저수준 렌더러에 대한 입력으로 작동합니다.
▪라이트 매핑, 환경 매핑 및 그림자는 일반적으로 적절한 렌더링 엔진 내에서 내부적으로 처리됩니다.

**- front end (프런트 엔드)**
▪대부분의 게임은 다양한 목적을 위해 3D 장면에 오버레이되는 일종의 2D 그래픽을 사용합니다.

• 게임의 헤드업 디스플레이(HUD)
•게임 내 메뉴, 콘솔 또는 기타 개발 도구
• 게임 내 그래픽 사용자 인터페이스(GUI)를 통해 플레이어는 자신의 캐릭터 인벤토리를 조작하고, 전투를 위한 유닛을 구성하거나 기타 복잡한 게임 내 작업을 수행할 수 있습니다.

▪일반적으로 직교 투영으로 질감이 있는 쿼드(삼각형 쌍)를 그려서 구현됩니다.
▪또는 항상 카메라를 향하도록 광고판이 붙은 쿼드와 함께 풀 3D로 렌더링될 수 있습니다.
▪풀 모션 비디오(FMV) 시스템과 인게임 시네마틱(IGC)도 이 레이어에 포함됩니다.

•이 시스템은 이전에 녹화된 영화 또는 영화 시퀀스를 재생하는 역할을 합니다.

**- 프로파일링 및 디버깅**

프로파일링 및 디버깅 도구
▪게임 엔지니어는 종종 게임 성능을 프로파일링해야 합니다.
▪메모리 리소스가 부족하여 개발자도 메모리 분석 도구를 만듭니다.

▪이러한 목적을 지원하기 위해 게임 엔진은 다음과 같은 도구를 포함합니다.

•코드를 수동으로 계측하는 메커니즘으로 특정 코드 섹션의 시간을 측정할 수 있습니다.
• 게임이 실행되는 동안 프로파일링 통계를 화면에 표시하는 기능.
• 성능 통계를 테스트 파일이나 Excel 스프레드시트로 덤프하는 기능.
•다양한 화면 표시를 포함하여 엔진 및 각 하위 시스템에서 사용 중인 메모리 양을 결정하는 기능.
• 게임 플레이 도중 게임이 종료될 때 메모리 사용량, 최고 수위 표시 및 누출 통계를 덤프하는 기능.
•디버그 출력의 다른 범주를 켜거나 끄고 출력의 자세한 수준을 제어하는 기능과 함께 디버그 인쇄 문을 코드 전체에 추가할 수 있는 도구.
• 게임 이벤트를 녹화하고 재생하는 기능.

▪언리얼 엔진에도 프로파일러가 있습니다.

1.연결된 세션 및 세션 정보
2.메인 툴바
3.데이터 그래프(전체)
4.데이터 그래프(로컬)
5. 필터 및 사전 설정
6.이벤트 그래프

**- Collision & Physics**

Collision & Physics

▪충돌 감지는 모든 게임에서 중요합니다.
▪게임 산업에서는 일반적으로 강체의 움직임(운동학)과 이러한 움직임을 발생시키는 힘과 토크(역학)에만 관심이 있기 때문에 강체 역학이 중요합니다.
▪충돌과 물리학은 일반적으로 매우 밀접하게 연결되어 있습니다. 이는 충돌이 감지되면 거의 항상 물리 통합 및 제약 조건 충족 논리의 일부로 해결되기 때문입니다.

▪Ragdoll physics (래그돌 물리학)

•래그돌은 뼈가 서로 상대적으로 움직일 수 있는 방법을 제한하는 제약 시스템으로 함께 묶인 여러 강체 모음입니다.
• 예를 들어 캐릭터가 죽으면 각 관절의 움직임에 대한 제한을 준수하면서 몸이 바닥으로 무너지기 시작합니다.

**- 골격 애니메이션**

골격 애니메이션

▪ 게임에 사용되는 애니메이션은 기본적으로 5가지 종류가 있습니다.
• 스프라이트/텍스처 애니메이션
• 강체 계층 구조 애니메이션
• 골격 애니메이션
• 정점 애니메이션
• 모프 타겟

▪ 스켈레탈 애니메이션은 모프 타겟과 버텍스 애니메이션을 사용할 수 있지만 게임에서 가장 널리 사용되는 애니메이션 방법입니다.

• 애니메이션 시스템은 스켈레톤의 모든 뼈에 대한 포즈를 생성한 다음 이러한 포즈를 매트릭스 팔레트로 렌더링 엔진에 전달합니다.
• 렌더러는 최종 블렌딩된 정점 위치를 생성하기 위해 팔레트의 매트릭스 매트릭스로 각 정점을 변환합니다.

▪ Inverse Animation (역 기구학)

• 역운동학은 운동학적 체인의 끝을 체인의 시작에 대해 주어진 위치와 방향에 배치하는 데 필요한 가변 조인트 매개변수를 계산하는 수학적 프로세스입니다.

▪ 애디티브 애니메이션

• 애디티브 애니메이션은 다른 클립을 사용하여 애니메이션을 결합하는 과정입니다.
• 예를 들어, '재장전'과 '걷기' 애니메이션을 추가하여 '걷는 동안 다시 장전' 애니메이션을 만들 수 있습니다.

**- HID**
Human Interface Device (휴먼 인터페이스 장치)(HID)

▪모든 게임은 다음을 포함한 다양한 휴먼 인터페이스 장치(HID)에서 얻은 플레이어의 입력을 처리해야 합니다.

•키보드와 마우스, 조이패드, 핸들, 낚싯대, 댄스 패드, 위모트 등과 같은 기타 특수 게임 컨트롤러

▪HID는 하드웨어에서 오는 원시 데이터를 메시지로 보냅니다.

**- online multiplayer (온라인 멀티플레이어)**

온라인 멀티플레이어 및 네트워크

▪많은 게임에서 여러 인간 플레이어가 단일 가상 세계에서 플레이할 수 있습니다.

•단일 화면 멀티플레이어: 단일 시스템에 연결된 두 개 이상의 휴먼 인터페이스 장치. 여러 플레이어 캐릭터가 하나의 가상 세계에 거주합니다.
•화면 분할 멀티플레이어: 여러 플레이어 캐릭터가 단일 가상 세계에 거주하며, 단일 게임기에 여러 HID가 부착되어 있지만 각각 고유한 카메라가 있으며 화면이 섹션으로 나누어져 각 플레이어가 자신의 캐릭터를 볼 수 있습니다.