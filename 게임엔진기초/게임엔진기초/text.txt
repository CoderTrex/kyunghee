7. 파일 시스템

파일 시스템 api
파일 시스템 api는 엔진 스패셜 api안에 있는 원시적인 api를  wrap을 한다.
-> 장점은 크로스 플랫폼에서 api를 원활하게 처리할 수 있음
-> 게임 엔진의 파일 시스템 api는 다른 대상 하드웨어 플랫폼 간의 차이점에서 보호 가음
-> 또한 os가 제공하지 않는 파일 시스템 api를 제공한다.

게임 엔진 파일 시스템 api아는 일반적으로 다음 지역을 기능적으로 다룬다.
-> 파일 이름과 경로
-> 열기 / 닫기 / 읽기 / 쓰기 -> 개별적인 파일에 대해서
-> 개별적인 디렉토리 내용 스캔
-> 비동기 파일의 i/o 요청 관리

파일 이름과 경로
경로는 문장 형태로 묘사되는 파일의 위치 또는 디렉토리 위치를 의미한다. -> 파일 시스템 종속성을 띄는
각각의 운영체제는 파일 시스템의 약간의 변주를 보인다.

unix :      '/'를 구분자로 사용한다.
max os :    ':'를 구분자로 사용한다. 
window :    ':'를 디스크 구분자로 사용한다. 
            원격 컴퓨터 디스크립터는 '\\' 이후 '\'를 사용한다.

유닉스와 이것의 다양성은 볼륨을 지원하지 않는다. 
분리된 디렉토리 종속성을 때문에 유닉스의 경로는 볼륨지정자를 가지지 않는다.

dos와 초기 윈도우 버전에서는 파일은 8글자 이내여야 하며, 확장자는 3글자여야 했다.
:은 윈도우와 dos에서 드라이브 지정자로 밖에 사용 못함

콘솔은 특정한 지정자를 사용해서 디스크를 나타낸다. 
dev_dbvd를 통해서 블루레이 디스크를 나타내고
dev_hddx를 통해서 하나 이상의 하드 디스크를 나타낸다.

path vs search path

path        :  경로는 하나의 파일이나 디렉토리의 경로를 나타내는 게 사용됨
search path :  콜론이나 세미 콜론 같은 특별한 문자열로 구분되는 상대경로이다.

디렉토리를 다루기 위한 다양한 방법
• 디렉터리 격리
• 경로 정규화
• 절대경로와 상대경로 전환
• 파일명 또는 확장자 얻기

스텐다드 C 라이브러리는 파일 읽고 쓰기를 위한 2가지 api를 제공함
-> 버퍼와 언버퍼 방식

buffer api :
- 버퍼 i/o api는 데이터 블럭을 제공하는데 이것이 바로 버퍼이다. 
  프로그램과 디스크 위의 파일간의 바이트 전잘 -> 소스의 방향으로서
- 바이트 바이 바이트 읽기 대신, 버퍼 결과 흐름은 버퍼들을 모와서 하나의 버퍼로 보낸다.
  os 파일 시스템은 데이터가 충분히 모이면 전달됨
- 가끔 이러한 타입의 api는 stream I/O api로 불린다. 왜나햐면 그들은 추상성을 제공한다. 
  이는 디스크 파일이 바이트의 흐름처럼 보이게 한다.
- 버퍼 I/O는 디렉토리 접근을 최소화 한다. 
- 파일 시스템 콜의 횟수를 줄인다.

unbuffer api :
- 버퍼화 되지 않은 결과는 프로그래머가 디스크에 많은 양의 시퀀스를 가지고 있을 때에
- 버퍼와 되지 않은 I/O는 보증하지 않는다. 
  데이터가 물리적 디스크에 접근했는지 여부에 대해서


synchronous file I/O : 
  스레드가 I/O를 I/O 요청이 끌날때 까지 다른 명령은 진행하지 않는다.

Asysynchronous file I/O : 
  많은 게임이 원활함을 제공하기 위해 스트리밍을 통한 
  스트리밍을하면서 게임이 진행되는 동안 다음 레벨에 대한 데이터를 진행함.
  스트리밍을 지원하기 위해서 우리는 i/o RUN time에 실시간으로 요청을 받아서 실행할 수 있음

priorities :

- 동기화 i/o 운영체제는 다양한 우선순위를 가진다. 파일 i/o가 리얼타임인 이후부터
- 예를 들어 하드에서 오디오 스트리밍 또는 블루레이와 하늘을 출력하고, 다음 오디오 버퍼를 로딩하는 것은
  게임 레벨의 청크와 텍스처를 출력하는 것보다 높은 우선순위를 가진다. 

higher priorities:
- streaming audio from the hard disk
- Bluray and playing it on the fly
- loading the next
- buffer full of audio data  

lower priorities:
- loading a texture or a chunk of a game level.

Asysynchronous file I/O:
- "Asysynchronous file I/O"는 스레드를 분리해 I/O를 관리한다.
- 메인 스레드는 함수를 호출한다.  
- 낮은 우선순위의 작업은 늦추고 높은 우선순위의 작업을 먼저 수행해서 각자의 데드라인을 맞출 수 있음
- 작업중에 다른 콜이 들어오면 block으로 작업을 제한한다.
- 요청이 완료되면, callback이 실행되는데 메인 스레드의 호출로 발생한다.
  그러므로 작동이 완료된 것을 공지한다.

callback

세마포어(Semaphore) : 

- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 
  여러 Process 혹은 Thread가 접근하는 것을 막아줌(즉, 동기화 대상이 하나 이상)

- 세마포어는 두 개의 원자 연산을 사용하는 신호 메커니즘입니다. 
  1) 대기 및 
  2) 프로세스 동기화를 위한 신호.


리소스 메니저의 역할:
리소스 관리자의 주요 역할 중 하나는 자산을 생성하고 엔진 준비 상태로 변환하는 데 사용되는 오프라인 요금 체인을 관리하는 것입니다.
다른 역할은 런타임에 리소스를 관리하여 게임에 필요하기 전에 리소스가 메모리에 로드되고 더 이상 필요하지 않을 때 메모리에서 언로드되도록 하는 것입니다.

런타임 리소스 매니징
게임 엔진 런타임 리소스 메니저는 다양한 번위의 책임을 가져야 한다.
이는 이것의 메모리 로드의 우선적인 의무사항에 관련되어있다.  
- 참조 무결성 [복합 리소르는 로드할때 하위 리소스가 로드되었는지 확인하고 모든 상호 참조를 적절하게 패치해야함]
- 사용되지 않는 리소스는 free되어야 한다.

guid : 모든 자원이 가지는 고유 식별자
- 대부분은 일반적으로 경로를 가진다.
- 패키지라고 알려져있는 곳에 저장됨 -> 그러므로 경로는 패키지의 고유 식별자가 될 수 없음
- 때문에 128비트의 고유 해시코드를 사용해서 이를 극복함 (하지만 덜 직관적임)
- 언리얼은 개별 리소스에 대한 폴더 계층 구조로 구성됨.
  -> 매우 유사한 이렇게 하면 고유 이름이 부여됨


리소스 레지스터리
- 딕셔너리 형태로 구현되어 있음
- 사용하지 않으면 레지스터리의 메모리 주소값이 삭제됨
- 사용하면 메모리 주소값을 불러옴

- 만약에 리소스를 리소스 레지스터리에서 찾지 못한다면, 
  그냥 raw하게 파일을 직접 찾게 된다. 이는 직관적이어 보일지는 몰라도
  많은 시간을 요구하는 작업으로 랙이 걸릴 수도 있다. 

이를 해결하기 위한 2가지 방법
- 다음 레벨로 넘어가기 전에 한번에 사용하게 되는 모든 리소스들을 로드함
- 비동식으로 수행되는 것으로 x레벨에 있을 때 Y레벨의 리소스들이 백그라운에서 로드됨
  이는 플레이어에게 free play 경험을 주지만 무지막지하게 어려움


heap-base 리소스 할당
- 메모리 파편화를 간단하게 무시하고, 범용 힙 할당자를 통해서 자원 분배
- 힙은 트리의 모든 노드가 특정 순서로 있는 특수 트리 기반 데이터 구조이다.
- 힙 기반 리소스 할당은 게임이 개인용 컴퓨터에서만 실행되는 경우에 가장 잘 작동합니다(OS는 우수한 가상 메모리 할당을 지원하므로).

stack 리소스 할당 
- 메모리 파편화 문제를 걱정할 이유가 없음 조각화 문제는 메모리가 연속적으로 할당되고 할당된 순서와 반대 순서로 해제되기 때문입니다.
- stack 메모리를 사용하는 예제
  -> 게임이 선형적이고, 레벨 중심 적이다.
  -> 각 레벨이 메모리에 들어갈 수 있음

stack-base 메모리 할당
1. global 자원 먼저 할당됨
2. 탑의 위치 마킹됨, 이 포지션이 free 될 수 있게 하기 위해서
3. 레벨을 로드해서 우리가 자원을 stack에 쉽게 할당함
4. 레벨이 마무리되면 우리는 쉽게 전에 마킹한대로 이동할 수 있음

stack -> 2개의 스텍 사용(양방향 데이터 사용)
낮은 스택이 영구적인 데이터 사용을 나타냄
높은 위치의 스텍은 동적인 메모리 할당을 진행함


pool-based resource allocation
- 동일한 사이즈의 chunk로 나누어서 사용함.
- pool-allocater에 의해서 chunk를 분배함
- 메모리 파편화가 발생하지 않음
- 이 방식에서는 모든 리소스가 chunk형식에 맞게 분배가 되어야 함


6page