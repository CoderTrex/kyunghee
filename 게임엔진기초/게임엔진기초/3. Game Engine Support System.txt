https://ahnanne.tistory.com/15
소개
    • 모든 게임 엔진에는 중요한 작업을 관리하는 낮은 수준의 지원 시스템이 필요합니다.
    • 엔진 시동 및 종료
    • 엔진 및 게임 기능 구성
    • 엔진의 메모리 사용량 관리
    • 파일 시스템에 대한 액세스 처리
    • 게임에서 사용하는 광범위한 이기종 자산 유형(메시, 텍스처, 애니메이션, 오디오)
    • 게임 개발팀에서 사용할 수 있는 디버깅 도구 제공
    • 이 강의는 대부분의 게임 엔진에서 발견되는 가장 낮은 수준의 지원 시스템에 초점을 맞출 것입니다.

C++ 정적 초기화 순서
    • 하위 시스템 간의 상호 종속성은 시작되어야 하는 순서를 암시적으로 정의합니다.
    • 하위 시스템 B가 하위 시스템 A에 종속되어 있으면 B를 초기화하기 전에 A를 시작해야 합니다.
    • 종료는 일반적으로 역순으로 발생하므로 B가 먼저 종료된 다음 A가 종료됩니다.

C++ 정적 초기화 순서
    • 대부분의 최신 게임 엔진에서 사용되는 프로그래밍 언어는 C++이므로 엔진의 하위 시스템을 시작하고 종료하기 위해 
      C++의 기본 시작 및 종료 의미 체계를 활용할 수 있는지 간단히 고려해야 합니다.
    • C++에서 전역 및 정적 개체는 프로그램의 진입점인 main() 또는 Windows의 WinMain()이 호출되기 전에 생성됩니다.
    • 전역 및 정적 클래스 인스턴스의 소멸자는 main()이 반환된 후에 호출됩니다.
    • 이러한 동작은 게임 엔진의 하위 시스템을 초기화하고 종료하는 데 바람직하지 않습니다.

    - 주요 하위 시스템을 구현하기 위한 일반적인 디자인 패턴은 각 하위 시스템에 대해 싱글톤 클래스(종종 관리자라고 함)를 정의하는 것입니다.
    - 구성 및 소멸 순서를 직접 제어할 방법이 없기 때문에 동적 메모리 할당 없이 싱글톤 인스턴스를 전역으로 정의할 수 없습니다.
    - 대신, 우리는 종종 트릭을 사용합니다. 함수 내에서 선언된 정적 변수는 main()이 호출되기 전에 생성되지 않고 해당 함수의 첫 번째 호출에서 생성됩니다.
    - 글로벌 싱글톤이 함수 정적인 경우 글로벌 싱글톤의 구성 순서를 제어할 수 있습니다.

c++ static destruction -> 이를 수행하는 더 우아한 방법이 있습니다.
    • 각 관리자가 자신을 글로벌 우선 순위 대기열에 등록한 다음 이 대기열을 이동하여 적절한 순서로 모든 관리자를 시작할 수 있습니다.
    • 우선순위 큐에서 우선순위가 높은 요소가 낮은 우선순위 요소보다 먼저 제공됩니다.
    • 우선순위 큐는 종종 힙으로 구현되지만 개념적으로는 힙과 다릅니다. 우선순위 큐는 '목록' 또는 '맵'과 같은 개념입니다.
    
    각 관리자가 자신이 의존하는 다른 관리자를 명시적으로 나열하도록 하여 관리자 간 종속성 그래프를 정의한 다음 
    상호 종속성을 고려하여 최적의 시작 순서를 계산하는 코드를 작성할 수 있습니다.

Stack allocation vs. Heap allocation
    ▪ 스택 할당은 함수 호출 스택과 함께 인접한 메모리 블록에서 발생합니다.
        • 할당될 메모리의 크기는 컴파일러와 함수가 호출될 때마다 알려집니다.
        • 함수 호출이 끝날 때마다 변수에 대한 메모리 할당이 해제됩니다.
    ▪ 따라서 프로그래머는 스택 변수의 메모리 할당 및 할당 해제에 대해 걱정할 필요가 없습니다.
        • 이러한 종류의 메모리 할당은 메서드가 실행을 마치는 즉시 해당 메서드에 속한 모든 데이터가 스택에서 
        자동으로 플러시되기 때문에 임시 메모리 할당이라고도 합니다.

    ▪ 힙 할당은 프로그래머가 작성한 명령을 실행하는 동안 발생합니다.
        • 객체를 만들 때마다 항상 힙 공간에 생성되고 이러한 객체에 대한 참조 정보는 항상 스택 메모리에 저장됩니다.
        • 힙 메모리 할당은 스택 메모리 할당만큼 안전하지 않습니다. 이 공간에 저장된 데이터는 모든 스레드에서 액세스하거나 볼 수 있기 때문입니다.
        • 프로그래머가 이 메모리를 잘 처리하지 못하면 프로그램에서 메모리 누수가 발생할 수 있습니다.


메모리 관리 및 게임 성능
    
    게임 개발자로서 우리는 항상 코드가 더 빨리 실행되도록 노력하고 있습니다.
    모든 소프트웨어의 성능은 사용하는 알고리즘이나 해당 알고리즘이 코딩된 효율성뿐만 아니라 프로그램이 메모리를 활용하는 방식에 따라 결정됩니다.
    
    ▪ 메모리는 두 가지 방식으로 성능에 영향을 미칩니다.
    • malloc() 또는 new()를 통한 동적 메모리 할당은 매우 느린 작업입니다. 
    이는 동적 할당을 모두 피하거나 할당 비용을 크게 줄이는 사용자 지정 메모리 할당자를 사용하여 개선할 수 있습니다.
    • 최신 CPU에서 소프트웨어의 성능은 종종 메모리 액세스 패턴에 의해 결정됩니다. 
    예를 들어, 연속적인 메모리 블록은 동일한 데이터가 광범위한 메모리 주소에 분산되는 경우보다 CPU에서 훨씬 더 효율적으로 작동할 수 있습니다.

Dynamic memory allocation
    ▪ malloc() free() 또는 new() delete() 연산자를 통한 동적 메모리 할당은 일반적으로 매우 느립니다.
    ▪ 높은 비용은 두 가지 주요 요인에 기인할 수 있습니다.
        • 힙 할당자는 범용 기능이므로 1바이트에서 1기가바이트까지 모든 할당 크기를 처리하도록 작성해야 합니다. 
          이를 위해서는 많은 관리 오버헤드가 필요합니다.
        • 대부분의 운영 체제에서 malloc() 또는 free()에 대한 호출은 먼저 사용자 모드에서 커널 모드로 컨텍스트 전환하고 요청을 처리한 다음 
          다시 프로그램으로 컨텍스트 전환해야 합니다. 이러한 컨텍스트 스위치는 매우 비쌀 수 있습니다.


    ▪ 사용자 지정 할당자는 다음 두 가지 이유로 운영 체제의 힙 할당자보다 더 나은 성능 특성을 가질 수 있습니다.
        • 사용자 지정 할당자는 미리 할당된 메모리 블록의 요청을 충족할 수 있습니다. 
          이를 통해 사용자 모드에서 실행하고 운영 체제로의 컨텍스트 전환 비용을 완전히 피할 수 있습니다.
        • 사용 패턴에 대한 다양한 가정을 통해 사용자 지정 할당자는 범용 힙 할당자보다 훨씬 더 효율적일 수 있습니다.

Stack based allocators
    ▪ 많은 게임은 패션처럼 스택에 메모리를 할당합니다.
    ▪ 새 게임 레벨이 로드될 때마다 메모리가 할당됩니다. 레벨이 로드되면 동적 메모리 할당이 거의 또는 전혀 발생하지 않습니다.
    ▪ Level이 끝나면(level이 지워지거나 실패함) 해당 데이터가 언로드되고 모든 메모리가 해제될 수 있습니다.
    ▪ 이러한 종류의 메모리 할당을 위해 데이터 구조와 같은 스택을 사용하는 것이 좋습니다.

    ▪ 스택 할당자는 구현하기가 매우 쉽습니다.
    ▪ 우리는 단순히 malloc() 또는 new()를 사용하거나 전역 바이트 배열을 선언하여 큰 연속 메모리 블록을 할당합니다.
    ▪ 스택의 맨 위를 가리키는 포인터가 설정되고 유지됩니다.
    ▪ 이 포인터 아래의 모든 메모리 주소는 사용 중인 것으로 간주되며 그 위의 모든 주소는 사용 가능한 것으로 간주됩니다.
    ▪ 최상위 포인터는 스택에서 가장 낮은 메모리 주소로 초기화됩니다.
    ▪ 각 할당 요청은 단순히 요청된 바이트 수만큼 포인터를 위로 이동합니다.
    ▪ 가장 최근에 할당된 블록은 위쪽 포인터를 블록 크기만큼 다시 아래로 이동하여 해제할 수 있습니다.

스택 할당자
    ▪ 임의의 순서로 메모리를 해제할 수 없습니다.
    ▪ 모든 해제는 할당된 순서와 반대 순서로 수행되어야 합니다.
    ▪ 이를 강제하기 위해 stack top을 이전에 표시한 위치로 되돌려 현재 top과 roll back 지점 사이의 
      모든 블록을 해제하는 기능을 제공합니다.

이중 종단 스택 할당자
    ▪ 이중 종단 스택 할당자는 두 개의 스택 할당자를 사용합니다. 하나는 블록의 맨 아래에서 
      위로 할당하고 다른 하나는 블록의 맨 위에서 아래로 할당합니다.
    ▪ 이중 종단 스택 할당자는 맨 아래 스택의 메모리 사용량과 맨 위 스택의 메모리 사용량 사이에 
      트레이드오프가 발생하도록 하여 메모리를 보다 효율적으로 사용하므로 유용합니다.
        • 경우에 따라 두 스택이 거의 같은 양의 메모리를 사용하고 블록 중간에서 만날 수 있습니다.
        • 다른 상황에서는 두 스택 중 하나가 다른 스택보다 훨씬 더 많은 메모리를 사용할 수 있지만 요청된 총 메모리 양이 
        두 스택이 공유하는 블록보다 크지 않은 한 모든 할당 요청은 여전히 충족될 수 있습니다.

바텀 값은 -> 계속해서 유지되는 값
탑 값은   -> 순간적으로 계산해야 하는 값

풀 할당자
    ▪ 게임 엔진 프로그래밍에서 각각 동일한 크기의 작은 메모리 블록을 많이 할당하는 것은 매우 일반적입니다.
        • 예를 들어 행렬, 반복자, 링크된 목록의 링크 또는 렌더링 가능한 메시 인스턴스를 할당하고 해제할 수 있습니다.
    ▪ 이러한 유형의 메모리 할당 패턴의 경우 풀 할당자가 종종 완벽한 선택입니다.
    ▪ 풀 할당자는 크기가 할당될 요소 크기의 정확한 배수인 큰 메모리 블록을 미리 할당하여 작동합니다.
        • 예를 들어, 4 × 4 행렬의 풀은 행렬당 16개의 요소와 요소당 4바이트(32비트 부동 소수점)를 곱한 64바이트의 정확한 배수입니다.
    ▪ 풀 내의 각 요소는 자유 요소의 연결된 목록에 추가됩니다. 풀이 처음 초기화되면 사용 가능한 목록에 모든 요소가 포함됩니다.
    ▪ 할당 요청이 이루어지면 우리는 단순히 free list에서 다음 free 요소를 가져와서 반환합니다.
    ▪ 요소가 해제되면 간단히 해제 목록으로 다시 추적합니다.

단일 프레임 및 이중 버퍼 메모리 할당자
    ▪ 거의 모든 게임 엔진은 게임 루프 중에 최소한 일부 임시 데이터를 할당합니다. 
    이 데이터는 루프의 각 반복이 끝날 때 폐기되거나 다음 프레임에서 사용된 후 폐기됩니다.
    ▪ 이 할당 패턴은 매우 일반적이어서 많은 엔진이 단일 프레임 및 이중 버퍼 할당자를 지원합니다.

단일 프레임 할당자
    ▪ 단일 프레임 할당자는 메모리 블록을 예약하고 위에서 설명한 간단한 스택 할당자로 관리함으로써 구현됩니다.
    ▪ 각 프레임이 시작될 때 스택의 위쪽 포인터가 메모리 블록의 아래쪽으로 지워집니다.
    ▪ 프레임 동안 이루어진 할당은 블록의 상단으로 갈수록 커집니다.

    ▪ 이득:
    - 할당된 메모리는 해제될 필요가 없습니다. 매 프레임 시작 시 할당자가 지워진다는 사실에 의존할 수 있습니다.
    - 눈부시게 빠름.

    ▪ 단점:
    - 단일 프레임 할당자를 사용하려면 프로그래머 측에서 합리적인 수준의 규율이 필요합니다.
    - 프로그래머는 프레임 경계를 넘어 단일 프레임 메모리 블록에 대한 포인터를 캐시해서는 안 됩니다.


이중 버퍼 할당자
    ▪ 이중 버퍼 할당자는 프레임 i에 할당된 메모리 블록을 프레임 (i + 1)에서 사용할 수 있도록 합니다.
    ▪ 이를 달성하기 위해 동일한 크기의 두 개의 단일 프레임 스택 할당자를 생성한 다음 매 프레임마다 이들 사이에 핑퐁합니다.
    ▪ 이런 종류의 할당자는 Xbox360, PlayStation 3 또는 PlayStation 4와 같은 멀티코어 게임 콘솔에서 비동기 처리 결과를 캐싱하는 데 매우 유용합니다.
    ▪ 프레임 i 에서 결과를 제공된 버퍼에 저장할 수 있습니다.
    ▪ 프레임 (i +1)에서 버퍼가 교체됩니다. 그런 다음 이전 프레임의 결과는 이제 비활성 버퍼에 있으므로 이 프레임에서 지워지지 않습니다.

커널이란 무엇입니까?
     커널은 시스템을 완전히 제어할 수 있는 운영 체제의 핵심 컴퓨터 프로그램입니다.
     컴퓨터 전원을 켤 때 커널은 부트스트랩 프로그램 다음에 시스템에서 실행되는 두 번째 프로그램입니다.
        • 부트스트랩 프로그램은 컴퓨터 시스템이 시작될 때 로드되고 실행되는 첫 번째 프로그램입니다.
        • 그런 다음 스토리지에서 커널을 찾아 메모리에 마운트합니다.
        • 커널은 시작의 나머지 부분을 처리합니다.