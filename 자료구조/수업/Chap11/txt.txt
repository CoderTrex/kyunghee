시험 : 
straight selection sort로 하면 어떻게 될 것인가? 
-> sort의 방법에 따라 달라지는 상황에 대해서 질문함

정렬되지 않은 배열에서 가장 작은 값을 찾기 위한 방법의 수 O(n)
정렬되지 않은 배열을 정렬하는 총 횟수는 : (n*(n-1))/2

(n*(n-1))/2 = 0.5N^2 - 0.5N => O(N^2)

버블 정렬 :
비교를 하고 비교를 시작한 숫자는 계속해서 비교를 해나간다.
알고리즘의 복잡도는 항상 O(N^2)이다.

피벗 :
- 중간 기준값이 될 것 
- 이것을 기준으로 앞에는 작은 수 뒤에는 큰수를 정렬한다.

quick sort의 split 작동 방식 :
    기본 : 왼쪽 값과 오른쪽 값을 동시에 할당해서 움직인다.
    1. 왼쪽 값은 움직이면서 피봇보다 더 크면 정지한다. 
    2. 오른쪽 값이 움직이면서 피봇보다 더 작으면 정지하고, 왼쪽의 값과 바꾼다.
    3. 다시 왼쪽이 움직이고 이를 반복하다가, 서로가 지나치게 되면 지나친 값과 swap한다.

quick sort의 worst case에서는 O(N^2)의 시간 복잡도를 가진다.
-> worst case : 역순 정렬이고, 피봇을 맨 앞에서부터 가져옴


merge sort
각각을 전부다 분해하고, 전부다 정렬이 되게 합쳐서 하나로 만든다.
-> 큰 데이터를 sort할때는 merge sort를 사용함.


heap sort와 quick sort는 stable 하지 않다 -> 같은 값을 가질때 원래의 위치를 지켜준다.

high probaility
: 찾게 될 가능성이 높은 것을은 맨앞으로 보냄

해쉬 function 
0. collision occur이게 발생하면 안됨
1. 골고루 퍼져있어야 함

문제점 번호가 겹치면 어떻게 할 것이냐?
1.  linear porbing      : 만약에 해당 자리에 숫자가 있으면, 점점 앞으로 자리를 옮겨서 데이터를 저장함.
                        -> 문제점 : 앞의 수를 지우게 되면 뒤에 것을 확인 못함

2. Rehashing            : 해싱을 다양한 방법으로 진행함
                        linear porbing은 리헤싱의 한 가지 방법 중 하나임

3. bucket and chaining  : 넣어두는 공간을 1. 다차원 배열로 처리하자 (bucket)
                                         2. 링크드 리스트로 처리하자 (chaining)

Radix sort (기수정렬)


비트 마스크 설계에 대해서 

원하는 비트의 위치를 알기 위해 -> 해당 위치를 제외하고 0으로 하고 해당위치는 1로 코딩

만약에 두자리 이동하기 위해서는 4를 곱하면 됨
2씩 곱하면서 'and' 연산을 진행하면 왼쪽로 이동하여 원하는 위치의 값을 알 수 있음


2씩 나누면서 'and' 연산을 진행하면 오른쪽로 이동하여 원하는 위치의 값을 알 수 있음

